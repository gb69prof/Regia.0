<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Regia – lezioni vive su LIM</title>

<style>
:root{ --bg:#111; --panel:#1e1e1e; --accent:#4da3ff; --text:#f2f2f2; }
*{ box-sizing:border-box; }
body{
  margin:0;
  font-family:system-ui,-apple-system,sans-serif;
  background:var(--bg);
  color:var(--text);
  overflow:hidden;
}

/* Layout */
#app{ display:grid; grid-template-columns:280px 1fr; height:100vh; }

/* Sidebar */
#scenes{
  background:var(--panel);
  padding:10px;
  overflow-y:auto;
  -webkit-overflow-scrolling:touch;
}
.scene{
  padding:12px;
  margin-bottom:8px;
  background:#2a2a2a;
  border-radius:10px;
  cursor:pointer;
  user-select:none;
}
.scene.active{ outline:2px solid var(--accent); }

/* Main */
#main{ display:flex; flex-direction:column; min-width:0; }
#toolbar{
  display:flex; gap:8px; padding:10px; background:#000;
  flex-wrap:wrap;
}
button{
  padding:12px 14px;
  font-size:16px;
  border:none;
  border-radius:10px;
  background:var(--accent);
  color:#000;
}
button.secondary{ background:#333; color:var(--text); }
button.danger{ background:#b43b3b; color:#fff; }
button:active{ transform:scale(0.98); }

#editor{
  flex:1;
  padding:16px;
  overflow-y:auto;
  -webkit-overflow-scrolling:touch;
}
input, textarea{
  width:100%;
  margin-bottom:10px;
  padding:12px;
  font-size:18px;
  border-radius:10px;
  border:none;
}
textarea{ min-height:140px; }

/* Projection */
#projection{
  position:fixed;
  inset:0;
  background:#000;
  color:#fff;
  display:none;
  padding:28px 28px 22px;
  overflow:hidden;
  touch-action:pan-y; /* scroll verticale testo */
}
#pTitle{ margin:0 0 14px; font-size:44px; line-height:1.1; }
#pText{ margin:0 0 16px; font-size:26px; line-height:1.35; white-space:pre-wrap; }

#pAsset{
  width:100%;
  height: calc(100% - 170px);
  display:flex;
  align-items:center;
  justify-content:center;
  position:relative;
}

/* Wrapper zoom/pan per immagini */
#zoomStage{
  width:100%;
  height:100%;
  position:relative;
  overflow:hidden;
  border-radius:12px;
  background:#000;
  display:none;
  touch-action:none; /* qui gestiamo noi pinch/drag */
}
#zoomImg{
  position:absolute;
  left:50%;
  top:50%;
  transform: translate(-50%, -50%) scale(1);
  transform-origin:center center;
  will-change: transform;
  max-width:none;
  max-height:none;
  user-select:none;
  -webkit-user-drag:none;
}

/* Asset generici */
#pAsset video, #pAsset audio, #pAsset iframe{
  max-width:100%;
  max-height:100%;
}

/* Projection controls */
#pControls{
  position:absolute;
  top:12px;
  right:12px;
  display:flex;
  gap:10px;
  z-index:20;
}
#pNav{
  position:absolute;
  bottom:12px;
  left:12px;
  right:12px;
  display:flex;
  justify-content:space-between;
  gap:10px;
  z-index:20;
}
.pBtn{
  padding:12px 14px;
  font-size:18px;
  border:none;
  border-radius:12px;
  background:rgba(255,255,255,0.16);
  color:#fff;
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
}
.pBtn:active{ transform:scale(0.98); }
.pBtn.primary{ background:rgba(77,163,255,0.95); color:#000; }
.pBtn.wide{ flex:1; }

/* Zoom controls (solo per immagini) */
#zoomControls{
  position:absolute;
  left:12px;
  top:12px;
  display:none;
  gap:10px;
  z-index:20;
}
#zoomControls .pBtn{ min-width:56px; text-align:center; }

/* Fallback asset container */
#pAssetFallback{
  width:100%;
  height:100%;
  display:flex;
  align-items:center;
  justify-content:center;
}

/* Black overlay */
#black{
  position:fixed;
  inset:0;
  background:#000;
  display:none;
  z-index:9999;
}
</style>
</head>

<body>

<div id="app">
  <div id="scenes"></div>

  <div id="main">
    <div id="toolbar">
      <button onclick="addScene()">+ Scena</button>
      <button class="secondary" onclick="deleteScene()">Elimina scena</button>
      <button class="secondary" onclick="startProjection()">Proiezione</button>
      <button class="secondary" onclick="exportProject()">Esporta</button>
      <button class="secondary" onclick="importProject()">Importa</button>
    </div>

    <div id="editor">
      <input id="title" placeholder="Titolo scena">
      <textarea id="text" placeholder="Testo / punti chiave"></textarea>

      <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-bottom:10px;">
        <input type="file" id="file" accept="image/*,video/*,audio/*,application/pdf" style="flex:1; min-width:260px;">
        <button class="secondary" onclick="clearAsset()">Rimuovi asset</button>
      </div>

      <div id="asset" style="opacity:0.85;"></div>

      <div style="opacity:0.75; font-size:14px; margin-top:10px; line-height:1.3;">
        Nota: le <b>immagini</b> vengono salvate nel progetto e tornano dopo Import.
        Video/Audio/PDF locali sono temporanei: per conservarli usa URL (es. GitHub/Drive con link diretto).
      </div>
    </div>
  </div>
</div>

<!-- Projection -->
<div id="projection">
  <div id="pControls">
    <button class="pBtn" onclick="toggleBlack()">Schermo nero</button>
    <button class="pBtn primary" id="fsBtn" onclick="toggleFullscreen()">Schermo intero</button>
    <button class="pBtn" onclick="stopProjection()">Esci</button>
  </div>

  <div id="zoomControls">
    <button class="pBtn" onclick="zoomStep(1.15)">+</button>
    <button class="pBtn" onclick="zoomStep(1/1.15)">−</button>
    <button class="pBtn" onclick="resetZoom()">Reset</button>
  </div>

  <h1 id="pTitle"></h1>
  <p id="pText"></p>

  <div id="pAsset">
    <div id="zoomStage">
      <img id="zoomImg" alt="immagine">
    </div>
    <div id="pAssetFallback"></div>
  </div>

  <div id="pNav">
    <button class="pBtn wide" onclick="prevScene()">◀ Indietro</button>
    <button class="pBtn wide" onclick="nextScene()">Avanti ▶</button>
  </div>
</div>

<div id="black"></div>

<script>
/* =========================
   MODEL
   ========================= */
let scenes = [];
let current = -1;

const $ = (id) => document.getElementById(id);
const scenesBox = $("scenes");
const projection = $("projection");
const black = $("black");
const fsBtn = $("fsBtn");

const zoomStage = $("zoomStage");
const zoomImg = $("zoomImg");
const zoomControls = $("zoomControls");
const fallback = $("pAssetFallback");

// Zoom state
let zScale = 1;
let zTx = 0;
let zTy = 0;

// Gesture state (zoom)
let gestureMode = null; // "drag" | "pinch"
let dragStart = null;
let pinchStart = null;

// Swipe in projection (prev/next)
let swipeStartX = null;
let swipeStartT = 0;

/* =========================
   SCENES UI
   ========================= */
function addScene(){
  scenes.push({ title:"Nuova scena", text:"", asset:null, type:null, assetName:null, assetIsEmbedded:false });
  selectScene(scenes.length - 1);
  renderScenes();
}

function deleteScene(){
  if (current < 0) return;
  scenes.splice(current, 1);
  if (scenes.length === 0) {
    scenes.push({ title:"Nuova scena", text:"", asset:null, type:null, assetName:null, assetIsEmbedded:false });
    current = 0;
  } else {
    current = Math.min(current, scenes.length - 1);
  }
  renderScenes();
  renderEditor();
}

function selectScene(i){
  current = i;
  renderScenes();
  renderEditor();
}

function renderScenes(){
  scenesBox.innerHTML = "";
  scenes.forEach((s, i) => {
    const d = document.createElement("div");
    d.className = "scene" + (i === current ? " active" : "");
    d.textContent = s.title || ("Scena " + (i+1));
    d.onclick = () => selectScene(i);
    scenesBox.appendChild(d);
  });
}

function renderEditor(){
  if(current < 0) return;
  const s = scenes[current];
  $("title").value = s.title || "";
  $("text").value = s.text || "";

  if (s.asset) {
    const kind = (s.type || "").startsWith("image/") ? "Immagine" : "Asset";
    const note = s.assetIsEmbedded ? " (salvata nel progetto)" : " (temporaneo)";
    $("asset").textContent = `${kind}: ${s.assetName || "file"}${note}`;
  } else {
    $("asset").textContent = "";
  }
}

$("title").addEventListener("input", () => {
  if(current < 0) return;
  scenes[current].title = $("title").value;
  renderScenes();
});

$("text").addEventListener("input", () => {
  if(current < 0) return;
  scenes[current].text = $("text").value;
});

/* =========================
   FILE INPUT (Soluzione A)
   - immagini: DataURL (persistono)
   - altri: blob URL (non persistono)
   ========================= */
$("file").addEventListener("change", (e) => {
  if(current < 0) return;
  const f = e.target.files[0];
  if(!f) return;

  const type = f.type || "";
  scenes[current].type = type;
  scenes[current].assetName = f.name || "file";

  // IMMAGINI: incorporazione nel progetto (DataURL)
  if (type.startsWith("image/")) {
    const r = new FileReader();
    r.onload = () => {
      scenes[current].asset = r.result;              // data:image/...;base64,...
      scenes[current].assetIsEmbedded = true;        // importante
      renderEditor();
    };
    r.readAsDataURL(f);
    return;
  }

  // ALTRI FILE: temporanei
  scenes[current].asset = URL.createObjectURL(f);    // blob:...
  scenes[current].assetIsEmbedded = false;
  renderEditor();
});

function clearAsset(){
  if(current < 0) return;
  scenes[current].asset = null;
  scenes[current].type = null;
  scenes[current].assetName = null;
  scenes[current].assetIsEmbedded = false;
  $("file").value = "";
  renderEditor();
}

/* =========================
   PROJECTION
   ========================= */
function startProjection(){
  if(current < 0) return;
  showProjection();
}

function stopProjection(){
  projection.style.display = "none";
  if (document.fullscreenElement) {
    document.exitFullscreen().catch(()=>{});
  }
}

function showProjection(){
  const s = scenes[current];
  projection.style.display = "block";
  $("pTitle").textContent = s.title || "";
  $("pText").textContent = s.text || "";

  // reset containers
  fallback.innerHTML = "";
  zoomStage.style.display = "none";
  zoomControls.style.display = "none";
  resetZoom(true);

  if (!s.asset) return;

  const t = s.type || "";

  if (t.startsWith("image/") || (typeof s.asset === "string" && s.asset.startsWith("data:image/"))) {
    zoomStage.style.display = "block";
    zoomControls.style.display = "flex";
    zoomImg.src = s.asset;
    resetZoom(true);

  } else if (t.startsWith("video/")) {
    const v = document.createElement("video");
    v.src = s.asset;
    v.controls = true;
    v.playsInline = true;
    v.style.maxWidth = "100%";
    v.style.maxHeight = "100%";
    v.style.borderRadius = "12px";
    fallback.appendChild(v);

  } else if (t.startsWith("audio/")) {
    const a = document.createElement("audio");
    a.src = s.asset;
    a.controls = true;
    fallback.appendChild(a);

  } else if (t === "application/pdf") {
    const iframe = document.createElement("iframe");
    iframe.src = s.asset;
    iframe.style.width = "100%";
    iframe.style.height = "100%";
    iframe.style.border = "0";
    iframe.style.borderRadius = "12px";
    fallback.appendChild(iframe);

  } else {
    const d = document.createElement("div");
    d.textContent = "Asset non supportato in anteprima.";
    fallback.appendChild(d);
  }
}

/* Prev/Next buttons */
function prevScene(){
  if(current > 0){
    current--;
    showProjection();
    renderScenes();
  }
}
function nextScene(){
  if(current < scenes.length - 1){
    current++;
    showProjection();
    renderScenes();
  }
}

/* Swipe support in projection (prev/next) */
projection.addEventListener("touchstart", (e) => {
  // non interferire con pinch/drag dell’immagine: se tocchi dentro zoomStage, non swipare.
  if (e.target && (e.target.id === "zoomStage" || e.target.id === "zoomImg")) return;
  if(e.touches.length !== 1) return;
  swipeStartX = e.touches[0].clientX;
  swipeStartT = Date.now();
}, { passive:true });

projection.addEventListener("touchend", (e) => {
  if(swipeStartX === null) return;
  const endX = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientX : swipeStartX;
  const dx = endX - swipeStartX;
  const dt = Date.now() - swipeStartT;

  if(Math.abs(dx) > 70 && dt < 700){
    if(dx > 0) prevScene();
    else nextScene();
  }

  swipeStartX = null;
}, { passive:true });

/* Black screen */
function toggleBlack(){
  black.style.display = (black.style.display === "block") ? "none" : "block";
}
black.addEventListener("click", () => black.style.display = "none");

/* Fullscreen */
async function toggleFullscreen(){
  try{
    if(!document.fullscreenElement){
      await projection.requestFullscreen();
      fsBtn.textContent = "Esci schermo intero";
    } else {
      await document.exitFullscreen();
      fsBtn.textContent = "Schermo intero";
    }
  } catch(err){
    fsBtn.textContent = "Fullscreen non disponibile";
    setTimeout(()=> fsBtn.textContent = "Schermo intero", 1200);
  }
}
document.addEventListener("fullscreenchange", () => {
  fsBtn.textContent = document.fullscreenElement ? "Esci schermo intero" : "Schermo intero";
});

/* =========================
   EXPORT / IMPORT (Soluzione A)
   - salva data:image/... per immagini embedded
   - salva http(s) per asset linkati
   - NON salva blob: (temporanei)
   ========================= */
function exportProject(){
  const safe = scenes.map(s => {
    const a = (typeof s.asset === "string") ? s.asset : null;

    const assetToSave =
      (a && (a.startsWith("data:image/") || a.startsWith("http://") || a.startsWith("https://")))
        ? a
        : null;

    return {
      title: s.title || "",
      text: s.text || "",
      type: s.type || null,
      assetName: s.assetName || null,
      assetIsEmbedded: !!(assetToSave && assetToSave.startsWith("data:image/")),
      asset: assetToSave
    };
  });

  const blob = new Blob([JSON.stringify(safe, null, 2)], { type:"application/json" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "regia.json";
  a.click();
}

function importProject(){
  const i = document.createElement("input");
  i.type = "file";
  i.accept = "application/json";
  i.onchange = (e) => {
    const f = e.target.files[0];
    if(!f) return;
    const r = new FileReader();
    r.onload = () => {
      try{
        const data = JSON.parse(r.result);
        scenes = (Array.isArray(data) ? data : []).map(s => ({
          title: s.title || "Scena",
          text: s.text || "",
          asset: s.asset || null,
          type: s.type || null,
          assetName: s.assetName || null,
          assetIsEmbedded: !!s.assetIsEmbedded || (typeof s.asset === "string" && s.asset.startsWith("data:image/"))
        }));

        if(scenes.length === 0){
          scenes.push({ title:"Nuova scena", text:"", asset:null, type:null, assetName:null, assetIsEmbedded:false });
        }
        selectScene(0);
      } catch(err){
        alert("JSON non valido.");
      }
    };
    r.readAsText(f);
  };
  i.click();
}

/* =========================
   ZOOM + PAN (IMMAGINI)
   ========================= */
function applyTransform(){
  zoomImg.style.transform = `translate(calc(-50% + ${zTx}px), calc(-50% + ${zTy}px)) scale(${zScale})`;
}
function clampPan(){
  const rect = zoomStage.getBoundingClientRect();
  const maxX = rect.width * 1.2;
  const maxY = rect.height * 1.2;
  if (zTx >  maxX) zTx =  maxX;
  if (zTx < -maxX) zTx = -maxX;
  if (zTy >  maxY) zTy =  maxY;
  if (zTy < -maxY) zTy = -maxY;
}
function resetZoom(silent=false){
  zScale = 1;
  zTx = 0;
  zTy = 0;
  clampPan();
  applyTransform();
  if(!silent){}
}
function zoomStep(factor){
  const next = zScale * factor;
  zScale = Math.min(8, Math.max(1, next));
  clampPan();
  applyTransform();
}
function dist(t1, t2){
  const dx = t2.clientX - t1.clientX;
  const dy = t2.clientY - t1.clientY;
  return Math.hypot(dx, dy);
}
function mid(t1, t2){
  return { x:(t1.clientX+t2.clientX)/2, y:(t1.clientY+t2.clientY)/2 };
}

zoomStage.addEventListener("touchstart", (e) => {
  e.preventDefault();

  if (e.touches.length === 1){
    gestureMode = "drag";
    dragStart = { x:e.touches[0].clientX, y:e.touches[0].clientY, tx:zTx, ty:zTy };

  } else if (e.touches.length === 2){
    gestureMode = "pinch";
    const d0 = dist(e.touches[0], e.touches[1]);
    const m0 = mid(e.touches[0], e.touches[1]);
    pinchStart = { d0, m0, scale0:zScale, tx0:zTx, ty0:zTy };
  }
}, { passive:false });

zoomStage.addEventListener("touchmove", (e) => {
  e.preventDefault();

  if (gestureMode === "drag" && e.touches.length === 1 && dragStart){
    const x = e.touches[0].clientX;
    const y = e.touches[0].clientY;
    zTx = dragStart.tx + (x - dragStart.x);
    zTy = dragStart.ty + (y - dragStart.y);
    clampPan();
    applyTransform();

  } else if (gestureMode === "pinch" && e.touches.length === 2 && pinchStart){
    const d1 = dist(e.touches[0], e.touches[1]);
    const m1 = mid(e.touches[0], e.touches[1]);

    const ratio = d1 / pinchStart.d0;
    zScale = Math.min(8, Math.max(1, pinchStart.scale0 * ratio));

    zTx = pinchStart.tx0 + (m1.x - pinchStart.m0.x);
    zTy = pinchStart.ty0 + (m1.y - pinchStart.m0.y);

    clampPan();
    applyTransform();
  }
}, { passive:false });

zoomStage.addEventListener("touchend", (e) => {
  e.preventDefault();
  if (e.touches.length === 0){
    gestureMode = null;
    dragStart = null;
    pinchStart = null;
  }
}, { passive:false });

/* Init */
addScene();
</script>

</body>
</html>
